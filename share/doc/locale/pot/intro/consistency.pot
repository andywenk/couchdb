# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013, The Apache Software Foundation
# This file is distributed under the same license as the Apache CouchDB package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Apache CouchDB 1.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-21 23:32\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../src/intro/consistency.rst:18
# 2081f9b0b6384d7c97b1b11bb6984128
msgid "Eventual Consistency"
msgstr ""

#: ../../src/intro/consistency.rst:20
# d2d9706c014b429eb0fe02029e9267f8
msgid "In the previous chapter, we saw that CouchDB's flexibility allows us to evolve our data as our applications grow and change. In this chapter, we'll explore how working \"with the grain\" of CouchDB promotes simplicity in our applications and helps us naturally build scalable, distributed systems."
msgstr ""

#: ../../src/intro/consistency.rst:27
# d241ffd7c88f498793fe5c50d3da6df2
msgid "Working with the Grain"
msgstr ""

#: ../../src/intro/consistency.rst:29
# e50f960f64c64de395943817d55d0833
msgid "A *distributed system* is a system that operates robustly over a wide network. A particular feature of network computing is that network links can potentially disappear, and there are plenty of strategies for managing this type of network segmentation. CouchDB differs from others by accepting eventual consistency, as opposed to putting absolute consistency ahead of raw availability, like `RDBMS`_ or `Paxos`_. What these systems have in common is an awareness that data acts differently when many people are accessing it simultaneously. Their approaches differ when it comes to which aspects of *consistency*, *availability*, or *partition* tolerance they prioritize."
msgstr ""

#: ../../src/intro/consistency.rst:39
# 6295c194d7de47abb712be08f14eee22
msgid "Engineering distributed systems is tricky. Many of the caveats and \"gotchas\" you will face over time aren't immediately obvious. We don't have all the solutions, and CouchDB isn't a panacea, but when you work with CouchDB's grain rather than against it, the path of least resistance leads you to naturally scalable applications."
msgstr ""

#: ../../src/intro/consistency.rst:45
# 7077edeae7c3476380554f0ddfebef21
msgid "Of course, building a distributed system is only the beginning. A website with a database that is available only half the time is next to worthless. Unfortunately, the traditional relational database approach to consistency makes it very easy for application programmers to rely on global state, global clocks, and other high availability no-nos, without even realizing that they're doing so. Before examining how CouchDB promotes scalability, we'll look at the constraints faced by a distributed system. After we've seen the problems that arise when parts of your application can't rely on being in constant contact with each other, we'll see that CouchDB provides an intuitive and useful way for modeling applications around high availability."
msgstr ""

#: ../../src/intro/consistency.rst:63
# 4018951574004fdba16296f748a45a8a
msgid "The CAP Theorem"
msgstr ""

#: ../../src/intro/consistency.rst:65
# a0d4344652004c46a170db3fa0d04e42
msgid "The CAP theorem describes a few different strategies for distributing application logic across networks. CouchDB's solution uses replication to propagate application changes across participating nodes. This is a fundamentally different approach from consensus algorithms and relational databases, which operate at different intersections of consistency, availability, and partition tolerance."
msgstr ""

#: ../../src/intro/consistency.rst:72
# e3c7324485f04d2f9bf408ed3cc46199
msgid "The CAP theorem, shown in :ref:`intro/consistency-01`, identifies three distinct concerns:"
msgstr ""

#: ../../src/intro/consistency.rst:75
# 2812cb37aa254da9ac4ea693a6cf5150
msgid "**Consistency**: All database clients see the same data, even with concurrent updates."
msgstr ""

#: ../../src/intro/consistency.rst:77
# 304e0d4e4a9b4a6da6c7c2c9e3549f39
msgid "**Availability**: All database clients are able to access some version of the data."
msgstr ""

#: ../../src/intro/consistency.rst:79
# 3dd49c4d85814885bfdc8ceaf7d0568f
msgid "**Partition tolerance**: The database can be split over multiple servers."
msgstr ""

#: ../../src/intro/consistency.rst:82
# e92d12ba87a641ee98c5b47ed507b9b6
msgid "Pick two."
msgstr ""

#: ../../src/intro/consistency.rst:90
# 9441ac3e1b6c4f588900d39985057d85
msgid "Figure 1. The CAP theorem"
msgstr ""

#: ../../src/intro/consistency.rst:92
# 897f4e73eb31493ea592e45b62d06862
msgid "When a system grows large enough that a single database node is unable to handle the load placed on it, a sensible solution is to add more servers. When we add nodes, we have to start thinking about how to partition data between them. Do we have a few databases that share exactly the same data? Do we put different sets of data on different database servers? Do we let only certain database servers write data and let others handle the reads?"
msgstr ""

#: ../../src/intro/consistency.rst:100
# edaa35bd682542cfa5eafa39f5760337
msgid "Regardless of which approach we take, the one problem we'll keep bumping into is that of keeping all these database servers in sync. If you write some information to one node, how are you going to make sure that a read request to another database server reflects this newest information? These events might be milliseconds apart. Even with a modest collection of database servers, this problem can become extremely complex."
msgstr ""

#: ../../src/intro/consistency.rst:107
# 6792c1d4fef84cb29d6df23859d5ca5f
msgid "When it's absolutely critical that all clients see a consistent view of the database, the users of one node will have to wait for any other nodes to come into agreement before being able to read or write to the database. In this instance, we see that availability takes a backseat to consistency. However, there are situations where availability trumps consistency:"
msgstr ""

#: ../../src/intro/consistency.rst:113
# 22df51baeb4c43cfb5036d414c2cf5a8
msgid "Each node in a system should be able to make decisions purely based on local state. If you need to do something under high load with failures occurring and you need to reach agreement, you're lost. If you're concerned about scalability, any algorithm that forces you to run agreement will eventually become your bottleneck. Take that as a given."
msgstr ""

#: ../../src/intro/consistency.rst:119
# 799a79f107b04af3b0cb5a460443621a
msgid "-- Werner Vogels, Amazon CTO and Vice President"
msgstr ""

#: ../../src/intro/consistency.rst:121
# 9523a4bb0274487580276e785c4e6098
msgid "If availability is a priority, we can let clients write data to one node of the database without waiting for other nodes to come into agreement. If the database knows how to take care of reconciling these operations between nodes, we achieve a sort of \"eventual consistency\" in exchange for high availability. This is a surprisingly applicable trade-off for many applications."
msgstr ""

#: ../../src/intro/consistency.rst:127
# a0a38ac799a5454a965b700165b0c757
msgid "Unlike traditional relational databases, where each action performed is necessarily subject to database-wide consistency checks, CouchDB makes it really simple to build applications that sacrifice immediate consistency for the huge performance improvements that come with simple distribution."
msgstr ""

#: ../../src/intro/consistency.rst:135
# 1911144df16049b1aae5fde438b35df5
msgid "Local Consistency"
msgstr ""

#: ../../src/intro/consistency.rst:137
# de95955a601f44699bee7d7bcd9ed9ce
msgid "Before we attempt to understand how CouchDB operates in a cluster, it's important that we understand the inner workings of a single CouchDB node. The CouchDB API is designed to provide a convenient but thin wrapper around the database core. By taking a closer look at the structure of the database core, we'll have a better understanding of the API that surrounds it."
msgstr ""

#: ../../src/intro/consistency.rst:145
# 876ceb391af04e26bc270fddc91d3cf1
msgid "The Key to Your Data"
msgstr ""

#: ../../src/intro/consistency.rst:147
# 5cea12c797e2410aa56d8932289d8fb5
msgid "At the heart of CouchDB is a powerful *B-tree* storage engine. A B-tree is a sorted data structure that allows for searches, insertions, and deletions in logarithmic time. As :ref:`intro/consistency-02` illustrates, CouchDB uses this B-tree storage engine for all internal data, documents, and views. If we understand one, we will understand them all."
msgstr ""

#: ../../src/intro/consistency.rst:160
# 0801be45728a4751a08e630df8ab0c79
msgid "Figure 2. Anatomy of a view request"
msgstr ""

#: ../../src/intro/consistency.rst:163
# 460436371ee9434c9ebe9ce6f2e8af1a
msgid "CouchDB uses MapReduce to compute the results of a view. MapReduce makes use of two functions, \"map\" and \"reduce\", which are applied to each document in isolation. Being able to isolate these operations means that view computation lends itself to parallel and incremental computation. More important, because these functions produce key/value pairs, CouchDB is able to insert them into the B-tree storage engine, sorted by key. Lookups by key, or key range, are extremely efficient operations with a B-tree, described in `big O` notation as ``O(log N)`` and ``O(log N + K)``, respectively."
msgstr ""

#: ../../src/intro/consistency.rst:173
# 824042799a494e4185cc5059a6ed6917
msgid "In CouchDB, we access documents and view results by key or key range. This is a direct mapping to the underlying operations performed on CouchDB's B-tree storage engine. Along with document inserts and updates, this direct mapping is the reason we describe CouchDB's API as being a thin wrapper around the database core."
msgstr ""

#: ../../src/intro/consistency.rst:179
# 037f80e9da4d4ac697f99a9f6f1693d0
msgid "Being able to access results by key alone is a very important restriction because it allows us to make huge performance gains. As well as the massive speed improvements, we can partition our data over multiple nodes, without affecting our ability to query each node in isolation. `BigTable`_, `Hadoop`_, `SimpleDB`_, and `memcached`_ restrict object lookups by key for  exactly these reasons."
msgstr ""

#: ../../src/intro/consistency.rst:193
# 3d15856c5a964ce1940df466bd33ac0b
msgid "No Locking"
msgstr ""

#: ../../src/intro/consistency.rst:195
# facca53669f34b9db69c1ce866be8f16
msgid "A table in a relational database is a single data structure. If you want to modify a table -- say, update a row -- the database system must ensure that nobody else is trying to update that row and that nobody can read from that row while it is being updated. The common way to handle this uses what's known as a lock. If multiple clients want to access a table, the first client gets the lock, making everybody else wait. When the first client's request is processed, the next client is given access while everybody else waits, and so on. This serial execution of requests, even when they arrived in parallel, wastes a significant amount of your server's processing power. Under high load, a relational database can spend more time figuring out who is allowed to do what, and in which order, than it does doing any actual work."
msgstr ""

#: ../../src/intro/consistency.rst:208
# 34a4e216ee594372b45d45e78fee0cb1
msgid "Modern relational databases avoid locks by implementing MVCC under the hood, but hide it from the end user, requiring them to coordinate concurrent changes of single rows or fields."
msgstr ""

#: ../../src/intro/consistency.rst:212
# 369e124d555149cb8715c2290f1de2c3
msgid "Instead of locks, CouchDB uses `Multi-Version Concurrency Control` (MVCC) to manage concurrent access to the database. :ref:`intro/consistency-03` illustrates the differences between MVCC and traditional locking mechanisms. MVCC means that CouchDB can run at full speed, all the time, even under high load. Requests are run in parallel, making excellent use of every last drop of processing power your server has to offer."
msgstr ""

#: ../../src/intro/consistency.rst:226
# 61a112dbe86c42819d7c20b9d047d1d3
msgid "Figure 3. MVCC means no locking"
msgstr ""

#: ../../src/intro/consistency.rst:229
# da25e7fad460432e8d50c22ab442f4f3
msgid "Documents in CouchDB are versioned, much like they would be in a regular version control system such as `Subversion`_. If you want to change a value in a document, you create an entire new version of that document and save it over the old one. After doing this, you end up with two versions of the same document, one old and one new."
msgstr ""

#: ../../src/intro/consistency.rst:235
# b869cb45b8414839a4648a347b7fe0d6
msgid "How does this offer an improvement over locks? Consider a set of requests wanting to access a document. The first request reads the document. While this is being processed, a second request changes the document. Since the second request includes a completely new version of the document, CouchDB can simply append it to the database without having to wait for the read request to finish."
msgstr ""

#: ../../src/intro/consistency.rst:242
# 90d80401efa5467ebb9d33db4a25bdd4
msgid "When a third request wants to read the same document, CouchDB will point it to the new version that has just been written. During this whole process, the first request could still be reading the original version."
msgstr ""

#: ../../src/intro/consistency.rst:246
# e22ddad616254753b79ac6f46172e854
msgid "A read request will always see the most recent snapshot of your database at the time of the beginning of the request."
msgstr ""

#: ../../src/intro/consistency.rst:253
# 9f5ba7eaf734463ca7c498fae7c1d2f8
msgid "Validation"
msgstr ""

#: ../../src/intro/consistency.rst:255
# b28d87ef9e8949c9914fcd33b5f7128b
msgid "As application developers, we have to think about what sort of input we should accept and what we should reject. The expressive power to do this type of validation over complex data within a traditional relational database leaves a lot to be desired. Fortunately, CouchDB provides a powerful way to perform per-document validation from within the database."
msgstr ""

#: ../../src/intro/consistency.rst:261
# 030ebaee262b4755835eebf475fd8ad0
msgid "CouchDB can validate documents using JavaScript functions similar to those used for MapReduce. Each time you try to modify a document, CouchDB will pass the validation function a copy of the existing document, a copy of the new document, and a collection of additional information, such as user authentication details. The validation function now has the opportunity to approve or deny the update."
msgstr ""

#: ../../src/intro/consistency.rst:268
# 0f177f54d5a84ad3be8c10400772e793
msgid "By working with the grain and letting CouchDB do this for us, we save ourselves a tremendous amount of CPU cycles that would otherwise have been spent serializing object graphs from SQL, converting them into domain objects, and using those objects to do application-level validation."
msgstr ""

#: ../../src/intro/consistency.rst:275
# b8e93f4ab5d4481e9acf3c2d549d403d
msgid "Distributed Consistency"
msgstr ""

#: ../../src/intro/consistency.rst:277
# fcd843fd89ec4f52be9e4dd18115acc5
msgid "Maintaining consistency within a single database node is relatively easy for most databases. The real problems start to surface when you try to maintain consistency between multiple database servers. If a client makes a write operation on server `A`, how do we make sure that this is consistent with server `B`, or `C`, or `D`? For relational databases, this is a very complex problem with entire books devoted to its solution. You could use multi-master, master/slave, partitioning, sharding, write-through caches, and all sorts of other complex techniques."
msgstr ""

#: ../../src/intro/consistency.rst:288
# b56e7b25cf5049c38f2c0f7d82d18329
msgid "Incremental Replication"
msgstr ""

#: ../../src/intro/consistency.rst:290
# e5245d3cbbea44a1a8f235000417c4b5
msgid "CouchDB's operations take place within the context of a single document. As CouchDB achieves eventual consistency between multiple databases by using incremental replication you no longer have to worry about your database servers being able to stay in constant communication. Incremental replication is a process where document changes are periodically copied between servers. We are able to build what's known as a *shared nothing* cluster of databases where each node is independent and self-sufficient, leaving no single point of contention across the system."
msgstr ""

#: ../../src/intro/consistency.rst:299
# 050c73eb9dce460988fd6f2d2d351bc7
msgid "Need to scale out your CouchDB database cluster? Just throw in another server."
msgstr ""

#: ../../src/intro/consistency.rst:301
# 2e00be04d675498b8b4116164cc9fcf9
msgid "As illustrated in :ref:`intro/consistency-04`, with CouchDB's incremental replication, you can synchronize your data between any two databases however you like and whenever you like. After replication, each database is able to work independently."
msgstr ""

#: ../../src/intro/consistency.rst:306
# 544dce457207472d97875b7e6a612149
msgid "You could use this feature to synchronize database servers within a cluster or between data centers using a job scheduler such as cron, or you could use it to synchronize data with your laptop for offline work as you travel. Each database can be used in the usual fashion, and changes between databases can be synchronized later in both directions."
msgstr ""

#: ../../src/intro/consistency.rst:319
# 480edeb08bb44e5bad7074be42875eba
msgid "Figure 4. Incremental replication between CouchDB nodes"
msgstr ""

#: ../../src/intro/consistency.rst:322
# f595b38b76d04bda802b05c1863b1200
msgid "What happens when you change the same document in two different databases and want to synchronize these with each other? CouchDB's replication system comes with automatic conflict detection and resolution. When CouchDB detects that a document has been changed in both databases, it flags this document as being in conflict, much like they would be in a regular version control system."
msgstr ""

#: ../../src/intro/consistency.rst:329
# c369a88502ed4507b29b60bc940896cc
msgid "This isn't as troublesome as it might first sound. When two versions of a document conflict during replication, the winning version is saved as the most recent version in the document's history. Instead of throwing the losing version away, as you might expect, CouchDB saves this as a previous version in the document's history, so that you can access it if you need to. This happens automatically and consistently, so both databases will make exactly the same choice."
msgstr ""

#: ../../src/intro/consistency.rst:337
# e1770145c6ae459eba50e9baf7dc6f15
msgid "It is up to you to handle conflicts in a way that makes sense for your application. You can leave the chosen document versions in place, revert to the older version, or try to merge the two versions and save the result."
msgstr ""

#: ../../src/intro/consistency.rst:344
# dd6dfd5c77fb4a5daca7405e3d1c079d
msgid "Case Study"
msgstr ""

#: ../../src/intro/consistency.rst:346
# 6818d53a057a4b82b13dc94711db7820
msgid "Greg Borenstein, a friend and coworker, built a small library for converting Songbird playlists to JSON objects and decided to store these in CouchDB as part of a backup application. The completed software uses CouchDB's MVCC and document revisions to ensure that Songbird playlists are backed up robustly between nodes."
msgstr ""

#: ../../src/intro/consistency.rst:353
# 46975287d7d24ad1bd237d51979480e0
msgid "`Songbird`_ is a free software media player with an integrated web browser, based on the Mozilla XULRunner platform. Songbird is available for Microsoft Windows, Apple Mac OS X, Solaris, and Linux."
msgstr ""

#: ../../src/intro/consistency.rst:359
# d102420fceae461eb349cf409d705f71
msgid "Let's examine the workflow of the Songbird backup application, first as a user backing up from a single computer, and then using Songbird to synchronize playlists between multiple computers. We'll see how document revisions turn what could have been a hairy problem into something that *just works*."
msgstr ""

#: ../../src/intro/consistency.rst:365
# 217ad553992e455496f1bc9fe3d02a38
msgid "The first time we use this backup application, we feed our playlists to the application and initiate a backup. Each playlist is converted to a JSON object and handed to a CouchDB database. As illustrated in :ref:`intro/consistency-05`, CouchDB hands back the document ID and revision of each playlist as it's saved to the database."
msgstr ""

#: ../../src/intro/consistency.rst:378
# 0dd64f5ddd2f4d63ac44c9b9fccdf125
msgid "Figure 5. Backing up to a single database"
msgstr ""

#: ../../src/intro/consistency.rst:381
# 0174e86383e4416b8417d2c3a2c5aef2
msgid "After a few days, we find that our playlists have been updated and we want to back up our changes. After we have fed our playlists to the backup application, it fetches the latest versions from CouchDB, along with the corresponding document revisions. When the application hands back the new playlist document, CouchDB requires that the document revision is included in the request."
msgstr ""

#: ../../src/intro/consistency.rst:388
# 59f47646b9d04b9f9e54c7d555b4b4bf
msgid "CouchDB then makes sure that the document revision handed to it in the request matches the current revision held in the database. Because CouchDB updates the revision with every modification, if these two are out of sync it suggests that someone else has made changes to the document between the time we requested it from the database and the time we sent our updates. Making changes to a document after someone else has modified it without first inspecting those changes is usually a bad idea."
msgstr ""

#: ../../src/intro/consistency.rst:396
# 46b5c50a21004c6dadca34aa6647da28
msgid "Forcing clients to hand back the correct document revision is the heart of CouchDB's optimistic concurrency."
msgstr ""

#: ../../src/intro/consistency.rst:399
# 4475472691044512b798eaff7ba24a71
msgid "We have a laptop we want to keep synchronized with our desktop computer. With all our playlists on our desktop, the first step is to \"restore from backup\" onto our laptop. This is the first time we've done this, so afterward our laptop  should hold an exact replica of our desktop playlist collection."
msgstr ""

#: ../../src/intro/consistency.rst:405
# 46c31ebb628a4b4498877a7ac32ac542
msgid "After editing our Argentine Tango playlist on our laptop to add a few new songs we've purchased, we want to save our changes. The backup application replaces the playlist document in our laptop CouchDB database and a new document revision is generated. A few days later, we remember our new songs and want to copy the playlist across to our desktop computer. As illustrated in :ref:`intro/consistency-06`, the backup application copies the new document and the new revision to the desktop CouchDB database. Both CouchDB databases now have the same document revision."
msgstr ""

#: ../../src/intro/consistency.rst:421
# 708490ec400c4513b0ba3b916bd38397
msgid "Figure 6. Synchronizing between two databases"
msgstr ""

#: ../../src/intro/consistency.rst:424
# 5f5ba90b5d0e44e2a5fe5fdcb0a0f84a
msgid "Because CouchDB tracks document revisions, it ensures that updates like these will work only if they are based on current information. If we had made modifications to the playlist backups between synchronization, things wouldn't go as smoothly."
msgstr ""

#: ../../src/intro/consistency.rst:429
# 6216f6b0ccc4482f956ee3863c884b77
msgid "We back up some changes on our laptop and forget to synchronize. A few days later, we're editing playlists on our desktop computer, make a backup, and want to synchronize this to our laptop. As illustrated in :ref:`intro/consistency-07`, when our backup application tries to replicate between the two databases, CouchDB sees that the changes being sent from our desktop computer are modifications of out-of-date documents and helpfully informs us that there has been a conflict."
msgstr ""

#: ../../src/intro/consistency.rst:437
# 1f79014e04af45589822912217b31554
msgid "Recovering from this error is easy to accomplish from an application perspective. Just download CouchDB's version of the playlist and provide an opportunity to merge the changes or save local modifications into a new playlist."
msgstr ""

#: ../../src/intro/consistency.rst:449
# 8d7b96f2388f4e389c47b148d48ad80f
msgid "Figure 7. Synchronization conflicts between two databases"
msgstr ""

#: ../../src/intro/consistency.rst:453
# c212283b6dbb4232b16d62f8b5b42b25
msgid "Wrapping Up"
msgstr ""

#: ../../src/intro/consistency.rst:455
# 47a173efb2174d1da7311cc019e98352
msgid "CouchDB's design borrows heavily from web architecture and the lessons learned deploying massively distributed systems on that architecture. By understanding why this architecture works the way it does, and by learning to spot which parts of your application can be easily distributed and which parts cannot, you'll enhance your ability to design distributed and scalable applications, with CouchDB or without it."
msgstr ""

#: ../../src/intro/consistency.rst:462
# 8b331dad18b149faab31ec86322d533a
msgid "We've covered the main issues surrounding CouchDB's consistency model and hinted at some of the benefits to be had when you work *with* CouchDB and not against it. But enough theory -- let's get up and running and see what all the fuss is about!"
msgstr ""

