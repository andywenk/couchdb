# 
msgid ""
msgstr ""
"Project-Id-Version: Apache CouchDB 1.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2013-10-21 22:51\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../src/replication/replicator.rst:16
msgid "Replicator Database"
msgstr ""

#: ../../src/replication/replicator.rst:18
msgid ""
"A database where you ``PUT``/``POST`` documents to trigger replications and "
"you ``DELETE`` to cancel ongoing replications. These documents have exactly "
"the same content as the JSON objects we used to ``POST`` to ``_replicate`` "
"(fields ``source``, ``target``, ``create_target``, ``continuous``, "
"``doc_ids``, ``filter``, ``query_params``."
msgstr ""

#: ../../src/replication/replicator.rst:24
msgid ""
"Replication documents can have a user defined ``_id``. Design documents (and"
" ``_local`` documents) added to the replicator database are ignored."
msgstr ""

#: ../../src/replication/replicator.rst:27
msgid ""
"The default name of this database is ``_replicator``. The name can be "
"changed in the ``local.ini`` configuration, section ``[replicator]``, "
"parameter ``db``."
msgstr ""

#: ../../src/replication/replicator.rst:32
msgid "Basics"
msgstr ""

#: ../../src/replication/replicator.rst:34
msgid "Let's say you PUT the following document into ``_replicator``:"
msgstr ""

#: ../../src/replication/replicator.rst:45
msgid "In the couch log you'll see 2 entries like these:"
msgstr ""

#: ../../src/replication/replicator.rst:52
msgid ""
"As soon as the replication is triggered, the document will be updated by "
"CouchDB with 3 new fields:"
msgstr ""

#: ../../src/replication/replicator.rst:67
msgid ""
"Special fields set by the replicator start with the prefix "
"``_replication_``."
msgstr ""

#: ../../src/replication/replicator.rst:70
msgid "``_replication_id``"
msgstr ""

#: ../../src/replication/replicator.rst:72
msgid ""
"The ID internally assigned to the replication. This is also the ID exposed "
"by ``/_active_tasks``."
msgstr ""

#: ../../src/replication/replicator.rst:75
msgid "``_replication_state``"
msgstr ""

#: ../../src/replication/replicator.rst:77
msgid "The current state of the replication."
msgstr ""

#: ../../src/replication/replicator.rst:79
msgid "``_replication_state_time``"
msgstr ""

#: ../../src/replication/replicator.rst:81
msgid ""
"A Unix timestamp (number of seconds since 1 Jan 1970) that tells us when the"
" current replication state (marked in ``_replication_state``) was set."
msgstr ""

#: ../../src/replication/replicator.rst:85
msgid ""
"When the replication finishes, it will update the ``_replication_state`` "
"field (and ``_replication_state_time``) with the value ``completed``, so the"
" document will look like:"
msgstr ""

#: ../../src/replication/replicator.rst:101
msgid ""
"When an error happens during replication, the ``_replication_state`` field "
"is set to ``error`` (and ``_replication_state_time`` gets updated of "
"course)."
msgstr ""

#: ../../src/replication/replicator.rst:105
msgid ""
"When you PUT/POST a document to the ``_replicator`` database, CouchDB will "
"attempt to start the replication up to 10 times (configurable under "
"``[replicator]``, parameter ``max_replication_retry_count``). If it fails on"
" the first attempt, it waits 5 seconds before doing a second attempt. If the"
" second attempt fails, it waits 10 seconds before doing a third attempt. If "
"the third attempt fails, it waits 20 seconds before doing a fourth attempt "
"(each attempt doubles the previous wait period). When an attempt fails, the "
"Couch log will show you something like:"
msgstr ""

#: ../../src/replication/replicator.rst:119
msgid ""
"The ``_replication_state`` field is only set to ``error`` when all the "
"attempts were unsuccessful."
msgstr ""

#: ../../src/replication/replicator.rst:122
msgid ""
"There are only 3 possible values for the ``_replication_state`` field: "
"``triggered``, ``completed`` and ``error``. Continuous replications never "
"get their state set to ``completed``."
msgstr ""

#: ../../src/replication/replicator.rst:127
msgid "Documents describing the same replication"
msgstr ""

#: ../../src/replication/replicator.rst:129
msgid ""
"Lets suppose 2 documents are added to the ``_replicator`` database in the "
"following order:"
msgstr ""

#: ../../src/replication/replicator.rst:140
msgid "and"
msgstr ""

#: ../../src/replication/replicator.rst:150
msgid ""
"Both describe exactly the same replication (only their ``_ids`` differ). In "
"this case document ``doc_A`` triggers the replication, getting updated by "
"CouchDB with the fields ``_replication_state``, ``_replication_state_time`` "
"and ``_replication_id``, just like it was described before. Document "
"``doc_B`` however, is only updated with one field, the ``_replication_id`` "
"so it will look like this:"
msgstr ""

#: ../../src/replication/replicator.rst:166
msgid "While document ``doc_A`` will look like this:"
msgstr ""

#: ../../src/replication/replicator.rst:179
msgid ""
"Note that both document get exactly the same value for the "
"``_replication_id`` field. This way you can identify which documents refer "
"to the same replication - you can for example define a view which maps "
"replication IDs to document IDs."
msgstr ""

#: ../../src/replication/replicator.rst:185
msgid "Canceling replications"
msgstr ""

#: ../../src/replication/replicator.rst:187
msgid ""
"To cancel a replication simply ``DELETE`` the document which triggered the "
"replication. The Couch log will show you an entry like the following:"
msgstr ""

#: ../../src/replication/replicator.rst:196
msgid ""
"You need to ``DELETE`` the document that triggered the replication. "
"``DELETE``-ing another document that describes the same replication but did "
"not trigger it, will not cancel the replication."
msgstr ""

#: ../../src/replication/replicator.rst:201
msgid "Server restart"
msgstr ""

#: ../../src/replication/replicator.rst:203
msgid ""
"When CouchDB is restarted, it checks its ``_replicator`` database and "
"restarts any replication that is described by a document that either has its"
" ``_replication_state`` field set to ``triggered`` or it doesn't have yet "
"the ``_replication_state`` field set."
msgstr ""

#: ../../src/replication/replicator.rst:209
msgid ""
"Continuous replications always have a ``_replication_state`` field with the "
"value ``triggered``, therefore they're always restarted when CouchDB is "
"restarted."
msgstr ""

#: ../../src/replication/replicator.rst:214
msgid "Changing the Replicator Database"
msgstr ""

#: ../../src/replication/replicator.rst:216
msgid ""
"Imagine your replicator database (default name is ``_replicator``) has the "
"two following documents that represent pull replications from servers A and "
"B:"
msgstr ""

#: ../../src/replication/replicator.rst:244
msgid ""
"Now without stopping and restarting CouchDB, you change the name of the "
"replicator database to ``another_replicator_db``:"
msgstr ""

#: ../../src/replication/replicator.rst:252
msgid ""
"As soon as this is done, both pull replications defined before, are stopped."
" This is explicitly mentioned in CouchDB's log:"
msgstr ""

#: ../../src/replication/replicator.rst:260
msgid ""
"Imagine now you add a replication document to the new replicator database "
"named ``another_replicator_db``:"
msgstr ""

#: ../../src/replication/replicator.rst:272
msgid ""
"From now own you have a single replication going on in your system: a pull "
"replication pulling from server X. Now you change back the replicator "
"database to the original one ``_replicator``:"
msgstr ""

#: ../../src/replication/replicator.rst:281
msgid ""
"Immediately after this operation, the replication pulling from server X will"
" be stopped and the replications defined in the ``_replicator`` database "
"(pulling from servers A and B) will be resumed."
msgstr ""

#: ../../src/replication/replicator.rst:285
msgid ""
"Changing again the replicator database to ``another_replicator_db`` will "
"stop the pull replications pulling from servers A and B, and resume the pull"
" replication pulling from server X."
msgstr ""

#: ../../src/replication/replicator.rst:290
msgid "Replicating the replicator database"
msgstr ""

#: ../../src/replication/replicator.rst:292
msgid ""
"Imagine you have in server C a replicator database with the two following "
"pull replication documents in it:"
msgstr ""

#: ../../src/replication/replicator.rst:319
msgid ""
"Now you would like to have the same pull replications going on in server D, "
"that is, you would like to have server D pull replicating from servers A and"
" B. You have two options:"
msgstr ""

#: ../../src/replication/replicator.rst:323
msgid "Explicitly add two documents to server's D replicator database"
msgstr ""

#: ../../src/replication/replicator.rst:325
msgid ""
"Replicate server's C replicator database into server's D replicator database"
msgstr ""

#: ../../src/replication/replicator.rst:328
msgid "Both alternatives accomplish exactly the same goal."
msgstr ""

#: ../../src/replication/replicator.rst:331
msgid "Delegations"
msgstr ""

#: ../../src/replication/replicator.rst:333
msgid ""
"Replication documents can have a custom ``user_ctx`` property. This property"
" defines the user context under which a replication runs. For the old way of"
" triggering replications (POSTing to ``/_replicate/``), this property was "
"not needed (it didn't exist in fact) - this is because at the moment of "
"triggering the replication it has information about the authenticated user. "
"With the replicator database, since it's a regular database, the information"
" about the authenticated user is only present at the moment the replication "
"document is written to the database - the replicator database implementation"
" is like a ``_changes`` feed consumer (with ``?include_docs=true``) that "
"reacts to what was written to the replicator database - in fact this feature"
" could be implemented with an external script/program. This implementation "
"detail implies that for non admin users, a ``user_ctx`` property, containing"
" the user's name and a subset of his/her roles, must be defined in the "
"replication document. This is ensured by the document update validation "
"function present in the default design document of the replicator database. "
"This validation function also ensure that a non admin user can set a user "
"name property in the ``user_ctx`` property that doesn't match his/her own "
"name (same principle applies for the roles)."
msgstr ""

#: ../../src/replication/replicator.rst:353
msgid ""
"For admins, the ``user_ctx`` property is optional, and if it's missing it "
"defaults to a user context with name null and an empty list of roles - this "
"mean design documents will not be written to local targets. If writing "
"design documents to local targets is desired, the a user context with the "
"roles ``_admin`` must be set explicitly."
msgstr ""

#: ../../src/replication/replicator.rst:359
msgid ""
"Also, for admins the ``user_ctx`` property can be used to trigger a "
"replication on behalf of another user. This is the user context that will be"
" passed to local target database document validation functions."
msgstr ""

#: ../../src/replication/replicator.rst:364
msgid "The ``user_ctx`` property only has effect for local endpoints."
msgstr ""

#: ../../src/replication/replicator.rst:366
msgid "Example delegated replication document:"
msgstr ""

#: ../../src/replication/replicator.rst:381
msgid ""
"As stated before, for admins the ``user_ctx`` property is optional, while "
"for regular (non admin) users it's mandatory. When the roles property of "
"``user_ctx`` is missing, it defaults to the empty list ``[ ]``."
msgstr ""
